{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 2,
   "id": "09524f38-1680-4c13-800a-53267be0ba8b",
   "metadata": {},
   "outputs": [],
   "source": [
    "##############################################################\n",
    "#                                                            #\n",
    "#    Mark Hoogendoorn and Burkhardt Funk (2017)              #\n",
    "#    Machine Learning for the Quantified Self                #\n",
    "#    Springer                                                #\n",
    "#    Chapter 4                                               #\n",
    "#                                                            #\n",
    "##############################################################\n",
    "\n",
    "# Updated by Dave Ebbelaar on 06-01-2023\n",
    "\n",
    "import numpy as np\n",
    "\n",
    "\n",
    "# This class performs a Fourier transformation on the data to find frequencies that occur\n",
    "# often and filter noise.\n",
    "class FourierTransformation:\n",
    "\n",
    "    # Find the amplitudes of the different frequencies using a fast fourier transformation. Here,\n",
    "    # the sampling rate expresses the number of samples per second (i.e. Frequency is Hertz of the dataset).\n",
    "    def find_fft_transformation(self, data, sampling_rate):\n",
    "        # Create the transformation, this includes the amplitudes of both the real\n",
    "        # and imaginary part.\n",
    "        transformation = np.fft.rfft(data, len(data))\n",
    "        return transformation.real, transformation.imag\n",
    "\n",
    "    # Get frequencies over a certain window.\n",
    "    def abstract_frequency(self, data_table, cols, window_size, sampling_rate):\n",
    "\n",
    "        # Create new columns for the frequency data.\n",
    "        freqs = np.round((np.fft.rfftfreq(int(window_size)) * sampling_rate), 3)\n",
    "\n",
    "        for col in cols:\n",
    "            data_table[col + \"_max_freq\"] = np.nan\n",
    "            data_table[col + \"_freq_weighted\"] = np.nan\n",
    "            data_table[col + \"_pse\"] = np.nan\n",
    "            for freq in freqs:\n",
    "                data_table[\n",
    "                    col + \"_freq_\" + str(freq) + \"_Hz_ws_\" + str(window_size)\n",
    "                ] = np.nan\n",
    "\n",
    "        # Pass over the dataset (we cannot compute it when we do not have enough history)\n",
    "        # and compute the values.\n",
    "        for i in range(window_size, len(data_table.index)):\n",
    "            for col in cols:\n",
    "                real_ampl, imag_ampl = self.find_fft_transformation(\n",
    "                    data_table[col].iloc[\n",
    "                        i - window_size : min(i + 1, len(data_table.index))\n",
    "                    ],\n",
    "                    sampling_rate,\n",
    "                )\n",
    "                # We only look at the real part in this implementation.\n",
    "                for j in range(0, len(freqs)):\n",
    "                    data_table.loc[\n",
    "                        i, col + \"_freq_\" + str(freqs[j]) + \"_Hz_ws_\" + str(window_size)\n",
    "                    ] = real_ampl[j]\n",
    "                # And select the dominant frequency. We only consider the positive frequencies for now.\n",
    "\n",
    "                data_table.loc[i, col + \"_max_freq\"] = freqs[\n",
    "                    np.argmax(real_ampl[0 : len(real_ampl)])\n",
    "                ]\n",
    "                data_table.loc[i, col + \"_freq_weighted\"] = float(\n",
    "                    np.sum(freqs * real_ampl)\n",
    "                ) / np.sum(real_ampl)\n",
    "                PSD = np.divide(np.square(real_ampl), float(len(real_ampl)))\n",
    "                PSD_pdf = np.divide(PSD, np.sum(PSD))\n",
    "                data_table.loc[i, col + \"_pse\"] = -np.sum(np.log(PSD_pdf) * PSD_pdf)\n",
    "\n",
    "        return data_table"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "b388a244-e851-4023-a976-720770fcb7fa",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
